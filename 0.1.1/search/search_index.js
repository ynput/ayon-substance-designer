var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Substance Designer Addon","text":"<p>Adobe Substance Designer integration for AYON.</p>"},{"location":"index.html#dev-resources","title":"Dev Resources","text":"<p>Scripting API: https://helpx.adobe.com/substance-3d-designer/scripting/scripting-api-reference.html</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_substancedesigner<ul> <li>addon</li> <li>api<ul> <li>lib</li> <li>pipeline</li> <li>plugin</li> <li>project_creation</li> </ul> </li> <li>deploy<ul> <li>ayon_plugin</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_sbsar</li> <li>create_textures</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_texture</li> </ul> </li> <li>publish<ul> <li>collect_current_file</li> <li>collect_textureset_images</li> <li>collect_workfile_representation</li> <li>extract_sbsar</li> <li>extract_textures</li> <li>increment_workfile</li> <li>save_workfile</li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>imageio</li> <li>main</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_substancedesigner/index.html","title":"ayon_substancedesigner","text":""},{"location":"autoapi/client/ayon_substancedesigner/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_substancedesigner/version.html","title":"version","text":"<p>Package declaring AYON addon 'substancedesigner' version.</p>"},{"location":"autoapi/client/ayon_substancedesigner/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.export_outputs_by_sd_graph","title":"<code>export_outputs_by_sd_graph(instance_name, target_graph, output_dir, extension, selected_map_identifiers)</code>","text":"<p>Modified and referenced from exportSDGraphOutputs in Substance Designer Python API. Export the textures from the output nodes of the specified SD Graphs</p> <p>Parameters:</p> Name Type Description Default <code>instance_name</code> <code>Instance</code> <p>instance name</p> required <code>target_graph</code> <code>SDGraph</code> <p>target SD Graph</p> required <code>output_dir</code> <code>str</code> <p>output directory</p> required <code>extension</code> <code>str</code> <p>extension</p> required <code>selected_map_identifiers</code> <code>set</code> <p>list of maps targeted to be exported</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>Shows if the maps are successfully exported</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def export_outputs_by_sd_graph(instance_name, target_graph, output_dir,\n                               extension, selected_map_identifiers):\n    \"\"\"\n    Modified and referenced from exportSDGraphOutputs in Substance Designer\n    Python API.\n    Export the textures from the output nodes of the specified SD Graphs\n\n    Args:\n        instance_name (Instance): instance name\n        target_graph (sd.api.sdgraph.SDGraph): target SD Graph\n        output_dir (str): output directory\n        extension (str): extension\n        selected_map_identifiers (set): list of maps targeted to be exported\n\n    Returns:\n        bool: Shows if the maps are successfully exported\n    \"\"\"\n    if not target_graph:\n        return False\n\n    if not issubclass(type(target_graph), sdsbscompgraph.SDSBSCompGraph):\n        return False\n\n    # Compute the SDSBSCompGraph so that all node's textures are computed\n    target_graph.compute()\n\n    # Get some information on the graph\n    graph_name = target_graph.getIdentifier()\n\n    for sd_node in target_graph.getOutputNodes():\n        node_definition = sd_node.getDefinition()\n        for output in sd_node.getProperties(\n            sdproperty.SDPropertyCategory.Output):\n                map_identifier = output.getId()\n                if map_identifier not in selected_map_identifiers:\n                    continue\n                output_properties = node_definition.getProperties(\n                    sdproperty.SDPropertyCategory.Output\n                )\n                for output_property in output_properties:\n                    # Get the property value\n                    property_value = sd_node.getPropertyValue(output_property)\n\n                    # Get the property value as texture\n                    property_texture = property_value.get()\n                    if not property_texture:\n                        continue\n\n                    filename = (\n                        f\"{instance_name}_{graph_name}_{map_identifier}.{extension}\"\n                    )\n                    texture_filename = os.path.abspath(\n                        os.path.join(output_dir, filename)\n                    )\n\n                    try:\n                        property_texture.save(texture_filename)\n                    except APIException:\n                        print('Fail to save texture %s' % texture_filename)\n\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.get_colorspace_data","title":"<code>get_colorspace_data(raw_colorspace=False)</code>","text":"<p>Get Colorspace data of the output map Args:     raw_colorspace (bool, optional): Use raw colorspace data.                                      Defaults to False.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>colorspace name</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def get_colorspace_data(raw_colorspace=False):\n    \"\"\"Get Colorspace data of the output map\n    Args:\n        raw_colorspace (bool, optional): Use raw colorspace data.\n                                         Defaults to False.\n\n    Returns:\n        str: colorspace name\n    \"\"\"\n    ctx = sd.getContext()\n    app = ctx.getSDApplication()\n\n    # Access the color management engine.\n    color_management = app.getColorManagementEngine()\n    if raw_colorspace:\n        return color_management.getRawColorSpaceName()\n    else:\n        return color_management.getWorkingColorSpaceName()\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.get_current_graph_name","title":"<code>get_current_graph_name()</code>","text":"<p>Get the name of the current SD graph</p> <p>Returns:</p> Name Type Description <code>str</code> <p>current SD graph name</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def get_current_graph_name():\n    \"\"\"Get the name of the current SD graph\n\n    Returns:\n        str: current SD graph name\n    \"\"\"\n    qt_ui = qt_ui_manager()\n    current_graph = qt_ui.getCurrentGraph()\n    if not current_graph:\n        return None\n\n    return current_graph.getIdentifier()\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.get_map_identifiers_by_graph","title":"<code>get_map_identifiers_by_graph(target_graph_name)</code>","text":"<p>Get map identifiers of the target SD graph</p> <p>Parameters:</p> Name Type Description Default <code>target_graph_name</code> <code>str</code> <p>target SD graph name</p> required <p>Returns:</p> Name Type Description <code>set</code> <p>all map identifiers</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def get_map_identifiers_by_graph(target_graph_name):\n    \"\"\"Get map identifiers of the target SD graph\n\n    Args:\n        target_graph_name (str): target SD graph name\n\n    Returns:\n        set: all map identifiers\n    \"\"\"\n    all_map_identifiers = set()\n    target_graph = get_sd_graph_by_name(target_graph_name)\n    if target_graph:\n        for output_node in target_graph.getOutputNodes():\n            for output in output_node.getProperties(\n                sd.api.sdproperty.SDPropertyCategory.Output):\n                    all_map_identifiers.add(output.getId())\n\n    return all_map_identifiers\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.get_output_maps_from_graphs","title":"<code>get_output_maps_from_graphs()</code>","text":"<p>Get Output Maps from Substance Designer graphs by package</p> <p>Returns:</p> Name Type Description <code>set</code> <p>name of the output maps from substance designer graphs</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def get_output_maps_from_graphs():\n    \"\"\"Get Output Maps from Substance Designer graphs by package\n\n    Returns:\n        set: name of the output maps from substance designer graphs\n    \"\"\"\n    all_output_maps = set()\n    current_package = get_package_from_current_graph()\n    for resource in current_package.getChildrenResources(True):\n        if resource.getClassName() == \"SDSBSCompGraph\":\n            for output_node in resource.getOutputNodes():\n                for output in set(output_node.getProperties(\n                    sd.api.sdproperty.SDPropertyCategory.Output)):\n                        all_output_maps.add(output.getId())\n\n    return all_output_maps\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.get_package_from_current_graph","title":"<code>get_package_from_current_graph()</code>","text":"<p>Get Package from the current graph.</p> <p>Returns:</p> Type Description <p>sd.api.sdpackage.SDPackage: A package with SDResource</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def get_package_from_current_graph():\n    \"\"\"Get Package from the current graph.\n\n    Returns:\n        sd.api.sdpackage.SDPackage: A package with SDResource\n    \"\"\"\n    qt_ui = qt_ui_manager()\n    current_graph = qt_ui.getCurrentGraph()\n    if not current_graph:\n        return None\n    return current_graph.getPackage()\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.get_sd_graph_by_name","title":"<code>get_sd_graph_by_name(graph_name)</code>","text":"<p>Get SD graph base on its name</p> <p>Parameters:</p> Name Type Description Default <code>graph_name</code> <code>str</code> <p>SD graph name</p> required <p>Returns:</p> Type Description <p>sd.api.sdgraph.SDGraph: SD Graph</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def get_sd_graph_by_name(graph_name):\n    \"\"\"Get SD graph base on its name\n\n    Args:\n        graph_name (str): SD graph name\n\n    Returns:\n        sd.api.sdgraph.SDGraph: SD Graph\n    \"\"\"\n    pkg_mgr = package_manager()\n    for package in pkg_mgr.getUserPackages():\n        for resource in package.getChildrenResources(True):\n            if (\n                resource.getClassName() == \"SDSBSCompGraph\"\n                and resource.getIdentifier() == graph_name\n            ):\n                return resource\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.get_sd_graphs_by_package","title":"<code>get_sd_graphs_by_package()</code>","text":"<p>Get Substance Designer Graphs by package</p> <p>Returns:</p> Name Type Description <code>list</code> <p>name of Substance Designer Graphs</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def get_sd_graphs_by_package():\n    \"\"\"Get Substance Designer Graphs by package\n\n    Returns:\n        list: name of Substance Designer Graphs\n    \"\"\"\n    current_package = get_package_from_current_graph()\n    return [\n        resource.getIdentifier()\n        for resource in\n        current_package.getChildrenResources(True)\n        if resource.getClassName() == \"SDSBSCompGraph\"\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.package_manager","title":"<code>package_manager()</code>","text":"<p>Get Package Manager of Substance Designer</p> <p>Returns:</p> Type Description <p>sd.api.sdpackagemgr.SDPackageMgr: Package Manager</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def package_manager():\n    \"\"\"Get Package Manager of Substance Designer\n\n    Returns:\n        sd.api.sdpackagemgr.SDPackageMgr: Package Manager\n    \"\"\"\n    app = sd.getContext().getSDApplication()\n    pkg_mgr = app.getPackageMgr()\n    return pkg_mgr\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.parsing_sd_data","title":"<code>parsing_sd_data(target_package, metadata_type, is_dictionary=True)</code>","text":"<p>Parse and convert Subsatnce Designer SDValue data to dictionary</p> <p>Parameters:</p> Name Type Description Default <code>target_package</code> <code>SDPackage</code> <p>target SD Package</p> required <code>metadata_type</code> <code>str</code> <p>Ayon metadata type</p> required <p>Returns:</p> Type Description <p>dict/list: metadata dict</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def parsing_sd_data(target_package, metadata_type: str, is_dictionary=True):\n    \"\"\"Parse and convert Subsatnce Designer SDValue data to dictionary\n\n    Args:\n        target_package (sd.api.sdpackage.SDPackage): target SD Package\n        metadata_type (str): Ayon metadata type\n\n    Returns:\n        dict/list: metadata dict\n    \"\"\"\n    metadata = {} if is_dictionary else []\n    package_metadata_dict = target_package.getMetadataDict()\n    with contextlib.suppress(APIException):\n        metadata_value = package_metadata_dict.getPropertyValueFromId(\n            metadata_type).get()\n        metadata = json.loads(metadata_value)\n\n    return metadata\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.qt_ui_manager","title":"<code>qt_ui_manager()</code>","text":"<p>Get Qt Python UI Manager of Substance Designer</p> <p>Returns:</p> Type Description <p>sd.api.qtforpythonuimgrwrapper.QtForPythonUIMgrWrapper: Qt Python UI Manager</p> Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def qt_ui_manager():\n    \"\"\"Get Qt Python UI Manager of Substance Designer\n\n    Returns:\n        sd.api.qtforpythonuimgrwrapper.QtForPythonUIMgrWrapper: Qt Python\n            UI Manager\n    \"\"\"\n    ctx = sd.getContext()\n    sd_app = ctx.getSDApplication()\n    qt_ui_mgr = sd_app.getQtForPythonUIMgr()\n    return qt_ui_mgr\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/lib.html#client.ayon_substancedesigner.api.lib.set_sd_metadata","title":"<code>set_sd_metadata(metadata_type, metadata)</code>","text":"<p>Set AYON-related metadata in Substance Painter</p> <p>Parameters:</p> Name Type Description Default <code>metadata_type</code> <code>str</code> <p>AYON metadata key</p> required <code>metadata</code> <code>dict / list</code> <p>AYON-related metadata</p> required Source code in <code>client/ayon_substancedesigner/api/lib.py</code> <pre><code>def set_sd_metadata(metadata_type: str, metadata):\n    \"\"\"Set AYON-related metadata in Substance Painter\n\n    Args:\n        metadata_type (str): AYON metadata key\n        metadata (dict/list): AYON-related metadata\n    \"\"\"\n    # Need to convert dict to string first\n    target_package = get_package_from_current_graph()\n    metadata_to_str = f\"{json.dumps(metadata)}\"\n    metadata_value = sd.api.sdvaluestring.SDValueString.sNew(metadata_to_str)\n    package_metadata_dict = target_package.getMetadataDict()\n    package_metadata_dict.setPropertyValueFromId(metadata_type, metadata_value)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/pipeline.html","title":"pipeline","text":"<p>Pipeline tools for Ayon Substance Designer integration.</p>"},{"location":"autoapi/client/ayon_substancedesigner/api/pipeline.html#client.ayon_substancedesigner.api.pipeline.get_instances","title":"<code>get_instances()</code>","text":"<p>Return all instances stored in the project instances as a list</p> Source code in <code>client/ayon_substancedesigner/api/pipeline.py</code> <pre><code>def get_instances():\n    \"\"\"Return all instances stored in the project instances as a list\"\"\"\n    current_package = get_package_from_current_graph()\n    if not current_package:\n        return []\n\n    get_instances_by_id = parsing_sd_data(\n        current_package, AYON_METADATA_INSTANCES_KEY) or {}\n    return list(get_instances_by_id.values())\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/pipeline.html#client.ayon_substancedesigner.api.pipeline.imprint","title":"<code>imprint(current_package, name, namespace, context, loader, identifier, options=None)</code>","text":"<p>Imprint a loaded container with metadata.</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>LoaderPlugin</code> <p>loader instance used to produce container.</p> required <code>identifier(str)</code> <p>SDResource identifier</p> required <code>options(dict)</code> <p>options</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_substancedesigner/api/pipeline.py</code> <pre><code>def imprint(current_package, name, namespace, context,\n            loader, identifier, options=None):\n    \"\"\"Imprint a loaded container with metadata.\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (load.LoaderPlugin): loader instance used to produce container.\n        identifier(str): SDResource identifier\n        options(dict): options\n\n    Returns:\n        None\n\n    \"\"\"\n    data = {\n        \"schema\": \"ayon:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": str(name),\n        \"namespace\": str(namespace) if namespace else None,\n        \"loader\": str(loader.__class__.__name__),\n        \"representation\": context[\"representation\"][\"id\"],\n        \"project_name\": context[\"project\"][\"name\"],\n        \"objectName\": identifier\n    }\n    if options:\n        for key, value in options.items():\n            data[key] = value\n    container_data = parsing_sd_data(\n        current_package, AYON_METADATA_CONTAINERS_KEY, is_dictionary=False)\n    container_data.append(data)\n    set_sd_metadata(AYON_METADATA_CONTAINERS_KEY, container_data)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/pipeline.html#client.ayon_substancedesigner.api.pipeline.remove_container_metadata","title":"<code>remove_container_metadata(container)</code>","text":"<p>Helper method to remove the data for a specific container</p> Source code in <code>client/ayon_substancedesigner/api/pipeline.py</code> <pre><code>def remove_container_metadata(container):\n    \"\"\"Helper method to remove the data for a specific container\"\"\"\n    current_package = get_package_from_current_graph()\n    all_container_metadata = parsing_sd_data(\n        current_package, AYON_METADATA_CONTAINERS_KEY, is_dictionary=False)\n    metadata_remainder = [\n        container_data for container_data in all_container_metadata\n        if container_data[\"objectName\"] != container[\"objectName\"]\n    ]\n    set_sd_metadata(AYON_METADATA_CONTAINERS_KEY, metadata_remainder)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/pipeline.html#client.ayon_substancedesigner.api.pipeline.remove_instance","title":"<code>remove_instance(instance_id)</code>","text":"<p>Helper method to remove the data for a specific container</p> Source code in <code>client/ayon_substancedesigner/api/pipeline.py</code> <pre><code>def remove_instance(instance_id):\n    \"\"\"Helper method to remove the data for a specific container\"\"\"\n    current_package = get_package_from_current_graph()\n    if current_package:\n        instances = parsing_sd_data(\n            current_package, AYON_METADATA_INSTANCES_KEY) or {}\n        instances.pop(instance_id, None)\n        set_sd_metadata(AYON_METADATA_INSTANCES_KEY, instances)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/pipeline.html#client.ayon_substancedesigner.api.pipeline.set_instance","title":"<code>set_instance(instance_id, instance_data, update=False)</code>","text":"<p>Helper method to directly set the data for a specific container</p> <p>Parameters:</p> Name Type Description Default <code>instance_id</code> <code>str</code> <p>Unique identifier for the instance</p> required <code>instance_data</code> <code>dict</code> <p>The instance data to store in the metaadata.</p> required Source code in <code>client/ayon_substancedesigner/api/pipeline.py</code> <pre><code>def set_instance(instance_id, instance_data, update=False):\n    \"\"\"Helper method to directly set the data for a specific container\n\n    Args:\n        instance_id (str): Unique identifier for the instance\n        instance_data (dict): The instance data to store in the metaadata.\n    \"\"\"\n    set_instances({instance_id: instance_data}, update=update)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/pipeline.html#client.ayon_substancedesigner.api.pipeline.set_instances","title":"<code>set_instances(instance_data_by_id, update=False)</code>","text":"<p>Store data for multiple instances at the same time.</p> <p>Parameters:</p> Name Type Description Default <code>instance_data_by_id</code> <code>dict</code> <p>instance data queried by id</p> required <code>update</code> <code>bool</code> <p>whether the data needs update. Defaults to False.</p> <code>False</code> Source code in <code>client/ayon_substancedesigner/api/pipeline.py</code> <pre><code>def set_instances(instance_data_by_id, update=False):\n    \"\"\"Store data for multiple instances at the same time.\n\n    Args:\n        instance_data_by_id (dict): instance data queried by id\n        update (bool, optional): whether the data needs update.\n            Defaults to False.\n    \"\"\"\n    current_package = get_package_from_current_graph()\n    if current_package:\n        instances = parsing_sd_data(\n            current_package, AYON_METADATA_INSTANCES_KEY) or {}\n        for instance_id, instance_data in instance_data_by_id.items():\n            if update:\n                existing_data = instances.get(instance_id, {})\n                existing_data.update(instance_data)\n            else:\n                instances[instance_id] = instance_data\n\n        set_sd_metadata(AYON_METADATA_INSTANCES_KEY, instances)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/plugin.html","title":"plugin","text":"<p>Creator plugin for creating textures.</p>"},{"location":"autoapi/client/ayon_substancedesigner/api/plugin.html#client.ayon_substancedesigner.api.plugin.TextureCreator","title":"<code>TextureCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Create a texture set.</p> Source code in <code>client/ayon_substancedesigner/api/plugin.py</code> <pre><code>class TextureCreator(Creator):\n    \"\"\"Create a texture set.\"\"\"\n    settings_category = \"substancedesigner\"\n\n    def create(self, product_name, instance_data, pre_create_data):\n        current_graph_name = get_current_graph_name()\n        if not current_graph_name:\n            raise CreatorError(\"Can't create a Texture Set instance without \"\n                               \"the Substance Designer Graph.\")\n\n        instance_data[\"graph_name\"] = current_graph_name\n\n        instance = self.create_instance_in_context(product_name,\n                                                   instance_data)\n        set_instance(\n            instance_id=instance[\"instance_id\"],\n            instance_data=instance.data_to_store()\n        )\n\n    def collect_instances(self):\n        for instance in get_instances():\n            if (instance.get(\"creator_identifier\") == self.identifier or\n                    instance.get(\"productType\") == self.product_type):\n                self.create_instance_in_context_from_existing(instance)\n\n    def update_instances(self, update_list):\n        instance_data_by_id = {}\n        for instance, _changes in update_list:\n            # Persist the data\n            instance_id = instance.get(\"instance_id\")\n            instance_data = instance.data_to_store()\n            instance_data_by_id[instance_id] = instance_data\n        set_instances(instance_data_by_id, update=True)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            remove_instance(instance[\"instance_id\"])\n            self._remove_instance_from_context(instance)\n\n    # Helper methods (this might get moved into Creator class)\n    def create_instance_in_context(self, product_name, data):\n        instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self.create_context.creator_adds_instance(instance)\n        return instance\n\n    def create_instance_in_context_from_existing(self, data):\n        instance = CreatedInstance.from_existing(data, self)\n        self.create_context.creator_adds_instance(instance)\n        return instance\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html","title":"project_creation","text":""},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.add_graphs_to_package","title":"<code>add_graphs_to_package(parsed_graph_names, parsed_dependencies, temp_package_filepath)</code>","text":"<p>Add graphs to the temp package</p> <p>Parameters:</p> Name Type Description Default <code>parsed_graph_names</code> <code>list</code> <p>parsed graph names</p> required <code>parsed_dependencies</code> <code>list</code> <p>parsed dependencies</p> required <code>temp_package_filepath</code> <code>str</code> <p>temp package filepath</p> required Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def add_graphs_to_package(\n        parsed_graph_names, parsed_dependencies, temp_package_filepath):\n    \"\"\"Add graphs to the temp package\n\n    Args:\n        parsed_graph_names (list): parsed graph names\n        parsed_dependencies (list): parsed dependencies\n        temp_package_filepath (str): temp package filepath\n\n    \"\"\"\n    # Parse the temp package file\n    unsaved_tree = etree.parse(temp_package_filepath)\n    unsaved_root = unsaved_tree.getroot()\n\n    # Find the &lt;content&gt; element in Unsaved_Package.xml\n    content_element = unsaved_root.find('content')\n\n    # Remove the existing &lt;content/&gt; element if it exists\n    if content_element is not None:\n        unsaved_root.remove(content_element)\n    # Create a new &lt;content&gt; element and append the copied &lt;graph&gt; element\n    new_content = etree.Element('content')\n    new_content.extend(parsed_graph_names)  # Append the copied &lt;graph&gt; element\n    unsaved_root.append(new_content)   # Add the new &lt;content&gt; to the root\n\n    if parsed_dependencies:\n        # Remove the existing &lt;dependencies/&gt; element if it exists\n        dependencies_element = unsaved_root.find('dependencies')\n        if dependencies_element is not None:\n            # Find the &lt;dependencies&gt; element in Unsaved_Package.xml\n            unsaved_root.remove(dependencies_element)\n\n        new_dependencies_content = etree.Element('dependencies')\n        # Append the copied &lt;dependency&gt; element\n        new_dependencies_content.extend(parsed_dependencies)\n        # Add the new &lt;dependencies&gt; to the root\n        unsaved_root.append(new_dependencies_content)\n\n    # Save the modified content for Substance file\n    unsaved_tree.write(\n        temp_package_filepath,\n        encoding='utf-8',\n        xml_declaration=True\n    )\n\n    log.info(\"All graphs are copied and pasted successfully!\")\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.create_project_with_from_template","title":"<code>create_project_with_from_template(project_settings=None)</code>","text":"<p>Create Project from template setting</p> <p>Parameters:</p> Name Type Description Default <code>project_settings</code> <code>str</code> <p>project settings. Defaults to None.</p> <code>None</code> Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def create_project_with_from_template(project_settings=None):\n    \"\"\"Create Project from template setting\n\n    Args:\n        project_settings (str, optional): project settings. Defaults to None.\n    \"\"\"\n    sd_context = sd.getContext()\n    sd_app = sd_context.getSDApplication()\n    sd_pkg_mgr = sd_app.getPackageMgr()\n\n    if project_settings is None:\n        project_settings = get_current_project_settings()\n\n    context = get_current_context()\n    project_name = context[\"project_name\"]\n\n    resources_dir = sd_app.getPath(SDApplicationPath.DefaultResourcesDir)\n    project_creation_settings = project_settings[\"substancedesigner\"].get(\n        \"project_creation\", {})\n\n    project_template_settings = project_creation_settings.get(\n        \"project_templates\", [])\n    if not project_creation_settings:\n        return\n\n    parsed_graph_names = []\n    output_res_by_graphs = {}\n    parsed_dependencies = []\n    for project_template_setting in project_template_settings:\n        graph_name = project_template_setting[\"grpah_name\"]\n        if project_template_setting[\"template_type\"] == (\n            \"default_substance_template\"\n            ):\n                project_template = project_template_setting.get(\n                    \"default_substance_template\")\n                template_filepath = get_template_filename_from_project(\n                    resources_dir, project_template\n                )\n        elif project_template_setting[\"template_type\"] == (\n            \"custom_template\"\n            ):\n                custom_template = project_template_setting[\"custom_template\"]\n                project_template = custom_template[\"custom_template_graph\"]\n                if not project_template:\n                    log.warning(\"Project template not set. \"\n                                \"Skipping project creation.\")\n                    continue\n\n                path = custom_template[\"custom_template_path\"]\n                if not path:\n                    log.warning(\"Template path not filled. \"\n                                \"Skipping project creation.\")\n                    continue\n                folder_entity, task_entity = _get_current_context_entities(\n                    context)\n                template_filepath = resolve_template_path(\n                    path, project_name, folder_entity, task_entity\n                )\n                if not os.path.exists(template_filepath):\n                    log.warning(\n                        f\"Template path '{template_filepath}' \"\n                        \"does not exist yet.\")\n                    continue\n        else:\n            task_type_template = project_template_setting[\"task_type_template\"]\n            folder_entity, task_entity = _get_current_context_entities(context)\n            filter_data = {\n                \"task_types\": task_type_template[\"task_types\"]\n            }\n            matched_task_type = filter_profiles(\n                project_template_settings, filter_data, logger=log)\n            if not matched_task_type:\n                log.warning(\"No matching task_type found. \"\n                            \"Skipping project creation.\")\n                continue\n\n            path = task_type_template[\"path\"]\n            template_filepath = resolve_template_path(\n                path, project_name, folder_entity, task_entity)\n            if not os.path.exists(template_filepath):\n                log.warning(f\"Template filepath '{template_filepath}'\"\n                            \" not found.\")\n                continue\n\n            project_template = task_entity[\"name\"]\n\n        template_filepath = os.path.normpath(template_filepath)\n\n        parsed_graph = parse_graph_from_template(\n            graph_name, project_template, template_filepath)\n        if parsed_graph is not None:\n            parsed_graph_names.append(parsed_graph)\n\n        output_res_by_graphs[graph_name] = (\n            project_template_setting[\"default_texture_resolution\"]\n        )\n        parsed_dependency_paths = parse_dependencies_from_template(\n            template_filepath)\n        parsed_dependencies.extend(parsed_dependency_paths)\n\n    if not parsed_graph_names:\n        return\n\n    # add graph with template\n    package, package_filepath = create_tmp_package_for_template(\n        sd_pkg_mgr, project_name\n    )\n\n    add_graphs_to_package(\n        parsed_graph_names, parsed_dependencies, package_filepath\n    )\n\n    sd_pkg_mgr.unloadUserPackage(package)\n    sd_pkg_mgr.loadUserPackage(\n        package_filepath, updatePackages=True, reloadIfModified=True\n    )\n\n    # set user-defined resolution by graphs\n    set_output_resolution_by_graphs(output_res_by_graphs)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.create_tmp_package_for_template","title":"<code>create_tmp_package_for_template(sd_pkg_mgr, project_name)</code>","text":"<p>Create temp substance package for template graph</p> <p>Parameters:</p> Name Type Description Default <code>sd_pkg_mgr</code> <code>SDPackageMgr</code> <p>package manager</p> required <code>project_name</code> <code>str</code> <p>project_name</p> required <p>Returns:</p> Type Description <p>sd.api.sdpackage.SDPackage, str: SD Package and template file path</p> Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def create_tmp_package_for_template(sd_pkg_mgr, project_name):\n    \"\"\"Create temp substance package for template graph\n\n    Args:\n        sd_pkg_mgr (sd.api.sdpackagemgr.SDPackageMgr): package manager\n        project_name (str): project_name\n\n    Returns:\n        sd.api.sdpackage.SDPackage, str: SD Package and template file path\n\n    \"\"\"\n    temp_filename = \"temp_ayon_package.sbs\"\n    for temp_package in sd_pkg_mgr.getUserPackages():\n        path = temp_package.getFilePath()\n        if os.path.basename(path) == temp_filename:\n            return temp_package, path\n\n    temp_package = sd_pkg_mgr.newUserPackage()\n    staging_dir = tempdir.get_temp_dir(\n        project_name, use_local_temp=True\n    )\n    path = os.path.join(staging_dir, temp_filename)\n    path = os.path.normpath(path)\n    sd_pkg_mgr.savePackageAs(temp_package, fileAbsPath=path)\n\n    return temp_package, path\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.get_template_filename_from_project","title":"<code>get_template_filename_from_project(resources_dir, project_template)</code>","text":"<p>Get template filename from ayon project settings</p> <p>Parameters:</p> Name Type Description Default <code>resources_dir</code> <code>SDApplicationPath</code> <p>resources dir</p> required <code>project_template</code> <code>str</code> <p>project template name</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>absolute filepath of the sbs template file.</p> Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def get_template_filename_from_project(resources_dir,\n                                       project_template):\n    \"\"\"Get template filename from ayon project settings\n\n    Args:\n        resources_dir (sd.api.sdapplication.SDApplicationPath): resources dir\n        project_template (str): project template name\n\n    Returns:\n        str: absolute filepath of the sbs template file.\n    \"\"\"\n    templates_dir = os.path.join(resources_dir, \"templates\")\n    if project_template == \"empty\":\n        return os.path.join(templates_dir, \"01_empty.sbs\")\n    if project_template in [\n        \"metallic_roughness\",\n        \"metallic_roughness_anisotropy\",\n        \"metallic_roughness_coated\",\n        \"metallic_roughness_sheen\",\n        \"adobe_standard_material\"\n    ]:\n        return os.path.join(\n            templates_dir, \"02_pbr_metallic_roughness.sbs\")\n    elif project_template == \"specular_glossiness\":\n        return os.path.join(\n            templates_dir, \"03_pbr_specular_glossiness.sbs\")\n    elif project_template == \"blinn\":\n        return os.path.join(\n            templates_dir, \"04_blinn.sbs\")\n    elif project_template == \"scan_metallic_roughness\":\n        return os.path.join(\n            templates_dir, \"05_scan_pbr_metallic_roughness.sbs\")\n    elif project_template == \"scan_specular_glossiness\":\n        return os.path.join(\n            templates_dir, \"06_scan_pbr_specular_glossiness.sbs\")\n    elif project_template == \"axf_to_metallic_roughness\":\n        return os.path.join(\n            templates_dir, \"07_axf_to_pbr_metallic_roughness.sbs\")\n    elif project_template == \"axf_to_specular_glossiness\":\n        return os.path.join(\n            templates_dir, \"08_axf_to_pbr_specular_glossiness.sbs\")\n    elif project_template == \"axf_to_axf\":\n        return os.path.join(\n            templates_dir, \"09_axf_to_axf.sbs\")\n    elif project_template == \"studio_panorama\":\n        return os.path.join(\n            templates_dir, \"10_studio_panorama.sbs\")\n    elif project_template in [\n        \"sp_filter_generic\",\n        \"sp_filter_specific\",\n        \"sp_filter_channel_mesh_maps\",\n        \"sp_generator_mesh_maps\"\n    ]:\n        return os.path.join(\n            templates_dir, \"11_substance_painter.sbs\")\n    elif project_template == \"sample_filter\":\n        return os.path.join(\n            templates_dir, \"12_substance_sampler.sbs\")\n    elif project_template == \"clo_metallic_roughness\":\n        return os.path.join(\n            templates_dir, \"13_clo_metallic_roughness.sbs\")\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.parse_dependencies_from_template","title":"<code>parse_dependencies_from_template(template_filepath)</code>","text":"<p>Parse dependencies from Substance template file</p> <p>Parameters:</p> Name Type Description Default <code>template_filepath</code> <code>str</code> <p>Substance template filepath</p> required <p>Returns:</p> Type Description <p>List[xml.etree.ElementTree.Element]: dependencies from the select template</p> Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def parse_dependencies_from_template(template_filepath):\n    \"\"\"Parse dependencies from Substance template file\n\n    Args:\n        template_filepath (str): Substance template filepath\n\n    Returns:\n        List[xml.etree.ElementTree.Element]: dependencies from\n            the select template\n    \"\"\"\n    dependencies = []\n    # Parse the template substance file\n    substance_tree = etree.parse(template_filepath)\n    substance_root = substance_tree.getroot()\n\n    for element in substance_root.find('.//dependencies'):\n        dependencies.append(element)\n    return dependencies\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.parse_graph_from_template","title":"<code>parse_graph_from_template(graph_name, project_template, template_filepath)</code>","text":"<p>Parse graph by project template name from Substance template file Args:     graph_name (str): graph_name     project_template (str): project template name     template_filepath (str): Substance template filepath</p> <p>Returns:</p> Type Description <p>List[xml.etree.ElementTree.Element]: graph(s) from the select template</p> Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def parse_graph_from_template(graph_name, project_template, template_filepath):\n    \"\"\"Parse graph by project template name from Substance template file\n    Args:\n        graph_name (str): graph_name\n        project_template (str): project template name\n        template_filepath (str): Substance template filepath\n\n    Returns:\n        List[xml.etree.ElementTree.Element]: graph(s) from the select template\n\n    \"\"\"\n    # Parse the template substance file\n    substance_tree = etree.parse(template_filepath)\n    substance_root = substance_tree.getroot()\n\n    # Find the &lt;graph&gt; element with the specified identifier\n    graph_element = None\n    for graph in substance_root.findall('.//graph'):\n        identifier = graph.find('identifier')\n        if identifier is not None and (\n            identifier.attrib.get('v') == project_template\n            ):\n                graph_element = graph\n                break\n\n    if graph_element:\n        identifier_element = graph_element.find('identifier')\n        if identifier.attrib.get('v') == project_template:\n            identifier_element.attrib['v'] = graph_name\n    else:\n        log.warning(\n            f\"Graph with identifier '{project_template}' \"\n            f\"not found in {template_filepath}.\"\n        )\n\n    return graph_element\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.resolve_template_path","title":"<code>resolve_template_path(path, project_name, folder_entity, task_entity)</code>","text":"<p>resolve template path for Substance files</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>_type_</code> <p>template path to resolve</p> required <code>project_name</code> <code>str</code> <p>project name</p> required <code>folder_entity</code> <code>dict</code> <p>folder entity data</p> required <code>task_name</code> <code>str</code> <p>task name</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>resolved path for Substance template file</p> Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def resolve_template_path(path, project_name, folder_entity, task_entity):\n    \"\"\"resolve template path for Substance files\n\n    Args:\n        path (_type_): template path to resolve\n        project_name (str): project name\n        folder_entity (dict): folder entity data\n        task_name (str): task name\n\n    Returns:\n        str: resolved path for Substance template file\n    \"\"\"\n    anatomy = Anatomy(project_name)\n    project_entity = ayon_api.get_project(project_name)\n    fill_data = get_template_data(\n        project_entity, folder_entity, task_entity)\n    fill_data[\"root\"] = anatomy.roots\n    result = StringTemplate.format_template(path, fill_data)\n    if result.solved:\n        path = result.normalized()\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/api/project_creation.html#client.ayon_substancedesigner.api.project_creation.set_output_resolution_by_graphs","title":"<code>set_output_resolution_by_graphs(resolution_size_by_graphs)</code>","text":"<p>Set output resolution per graph accordingly to Ayon settings</p> <p>Parameters:</p> Name Type Description Default <code>package</code> <code>SDPackage</code> <p>temp package for graphs</p> required <code>resolution_size_by_graphs</code> <code>dict</code> <p>resolution data for each graph</p> required Source code in <code>client/ayon_substancedesigner/api/project_creation.py</code> <pre><code>def set_output_resolution_by_graphs(resolution_size_by_graphs):\n    \"\"\"Set output resolution per graph accordingly to Ayon settings\n\n    Args:\n        package (sd.api.sdpackage.SDPackage): temp package for graphs\n        resolution_size_by_graphs (dict): resolution data for each graph\n    \"\"\"\n    for graph_name, res_size in resolution_size_by_graphs.items():\n        graph = get_sd_graph_by_name(graph_name)\n        output_size = graph.getPropertyFromId(\n                \"$outputsize\", SDPropertyCategory.Input\n        )\n        graph.setPropertyInheritanceMethod(\n            output_size, SDPropertyInheritanceMethod.Absolute\n        )\n        graph.setPropertyValue(\n            output_size, SDValueInt2.sNew(int2(res_size, res_size))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/deploy/index.html","title":"deploy","text":""},{"location":"autoapi/client/ayon_substancedesigner/deploy/ayon_plugin.html","title":"ayon_plugin","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/create_sbsar.html","title":"create_sbsar","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/create_sbsar.html#client.ayon_substancedesigner.plugins.create.create_sbsar.CreateSbsar","title":"<code>CreateSbsar</code>","text":"<p>               Bases: <code>TextureCreator</code></p> <p>Create a texture set.</p> Source code in <code>client/ayon_substancedesigner/plugins/create/create_sbsar.py</code> <pre><code>class CreateSbsar(TextureCreator):\n    \"\"\"Create a texture set.\"\"\"\n    identifier = \"io.ayon.creators.substancedesigner.sbsar\"\n    label = \"Sbsar\"\n    product_type = \"sbsar\"\n    icon = \"picture-o\"\n\n    default_variant = \"Main\"\n    settings_category = \"substancedesigner\"\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/create_textures.html","title":"create_textures","text":"<p>Creator plugin for creating textures.</p>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/create_textures.html#client.ayon_substancedesigner.plugins.create.create_textures.CreateTextures","title":"<code>CreateTextures</code>","text":"<p>               Bases: <code>TextureCreator</code></p> <p>Create a texture set.</p> Source code in <code>client/ayon_substancedesigner/plugins/create/create_textures.py</code> <pre><code>class CreateTextures(TextureCreator):\n    \"\"\"Create a texture set.\"\"\"\n    identifier = \"io.ayon.creators.substancedesigner.textureset\"\n    label = \"Textures\"\n    product_type = \"textureSet\"\n    icon = \"picture-o\"\n\n    default_variant = \"Main\"\n    settings_category = \"substancedesigner\"\n    review = False\n    exportFileFormat = \"png\"\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        \"\"\"\n        The default product name templates for Unreal include {asset} and thus\n        we should pass that along as dynamic data.\n        \"\"\"\n        dynamic_data = super(CreateTextures, self).get_dynamic_data(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance\n        )\n        dynamic_data[\"asset\"] = folder_entity[\"name\"]\n        return dynamic_data\n\n    def create(self, product_name, instance_data, pre_create_data):\n        current_graph_name = get_current_graph_name()\n        if not current_graph_name:\n            raise CreatorError(\"Can't create a Texture Set instance without \"\n                               \"the Substance Designer Graph.\")\n        # Transfer settings from pre create to instance\n        creator_attributes = instance_data.setdefault(\n            \"creator_attributes\", dict())\n        for key in [\n            \"review\",\n            \"exportFileFormat\",\n            \"exportedGraphs\",\n            \"exportedGraphsOutputs\"\n        ]:\n            if key in pre_create_data:\n                creator_attributes[key] = pre_create_data[key]\n\n        instance = self.create_instance_in_context(product_name,\n                                                   instance_data)\n        set_instance(\n            instance_id=instance[\"instance_id\"],\n            instance_data=instance.data_to_store()\n        )\n\n    def get_instance_attr_defs(self):\n        return [\n            BoolDef(\"review\",\n                    label=\"Review\",\n                    tooltip=\"Mark as reviewable\",\n                    default=self.review),\n            EnumDef(\"exportFileFormat\",\n                    items={\n                        # TODO: Get available extensions from substance API\n                        \"bmp\": \"bmp\",\n                        \"dds\": \"dds\",\n                        \"jpeg\": \"jpeg\",\n                        \"jpg\": \"jpg\",\n                        \"png\": \"png\",\n                        \"tga\": \"targa\",\n                        \"tif\": \"tiff\",\n                        \"surface\": \"surface\",\n                        \"hdr\": \"hdr\",\n                        \"exr\": \"exr\",\n                        \"jif\": \"jif\",\n                        \"jpe\": \"jpe\",\n                        \"webp\": \"webp\",\n                        # TODO: File formats that combine the exported textures\n                        #   like psd are not correctly supported due to\n                        #   publishing only a single file\n                        # \"sbsar\": \"sbsar\",\n                    },\n                    default=self.exportFileFormat,\n                    label=\"File type\"),\n            EnumDef(\"exportedGraphs\",\n                    items=get_sd_graphs_by_package(),\n                    multiselection=True,\n                    default=None,\n                    label=\"Graphs To be Exported\"),\n            EnumDef(\"exportedGraphsOutputs\",\n                    items=get_output_maps_from_graphs(),\n                    multiselection=True,\n                    default=None,\n                    label=\"Graph Outputs To be Exported\")\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/create_textures.html#client.ayon_substancedesigner.plugins.create.create_textures.CreateTextures.get_dynamic_data","title":"<code>get_dynamic_data(project_name, folder_entity, task_entity, variant, host_name, instance)</code>","text":"<p>The default product name templates for Unreal include {asset} and thus we should pass that along as dynamic data.</p> Source code in <code>client/ayon_substancedesigner/plugins/create/create_textures.py</code> <pre><code>def get_dynamic_data(\n    self,\n    project_name,\n    folder_entity,\n    task_entity,\n    variant,\n    host_name,\n    instance\n):\n    \"\"\"\n    The default product name templates for Unreal include {asset} and thus\n    we should pass that along as dynamic data.\n    \"\"\"\n    dynamic_data = super(CreateTextures, self).get_dynamic_data(\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    )\n    dynamic_data[\"asset\"] = folder_entity[\"name\"]\n    return dynamic_data\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/create/create_workfile.html#client.ayon_substancedesigner.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_substancedesigner/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    identifier = \"io.ayon.creators.substancedesigner.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n    icon = \"document\"\n\n    default_variant = \"Main\"\n    settings_category = \"substancedesigner\"\n\n    def create(self):\n        current_package = get_package_from_current_graph()\n        if not current_package:\n            return\n        variant = self.default_variant\n        project_name = self.project_name\n        folder_path = self.create_context.get_current_folder_path()\n        task_name = self.create_context.get_current_task_name()\n        host_name = self.create_context.host_name\n\n        # Workfile instance should always exist and must only exist once.\n        # As such we'll first check if it already exists and is collected.\n        current_instance = next(\n            (\n                instance for instance in self.create_context.instances\n                if instance.creator_identifier == self.identifier\n            ), None)\n\n        current_folder_path = None\n        if current_instance is not None:\n            current_folder_path = current_instance[\"folderPath\"]\n\n        if current_instance is None:\n            self.log.info(\"Auto-creating workfile instance...\")\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name, folder_path\n            )\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], task_name\n            )\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n            data = {\n                \"folderPath\": folder_path,\n                \"task\": task_name,\n                \"variant\": variant\n            }\n            current_instance = self.create_instance_in_context(product_name,\n                                                               data)\n        elif (\n            current_folder_path != folder_path\n            or current_instance[\"task\"] != task_name\n        ):\n            # Update instance context if is not the same\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name, folder_path\n            )\n            task_entity = ayon_api.get_task_by_name(\n                project_name, folder_entity[\"id\"], task_name\n            )\n            product_name = self.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name,\n            )\n            current_instance[\"folderPath\"] = folder_path\n            current_instance[\"task\"] = task_name\n            current_instance[\"productName\"] = product_name\n\n        set_instance(\n            instance_id=current_instance.get(\"instance_id\"),\n            instance_data=current_instance.data_to_store()\n        )\n\n    def collect_instances(self):\n        for instance in get_instances():\n            if (instance.get(\"creator_identifier\") == self.identifier or\n                    instance.get(\"productType\") == self.product_type):\n                self.create_instance_in_context_from_existing(instance)\n\n    def update_instances(self, update_list):\n        instance_data_by_id = {}\n        for instance, _changes in update_list:\n            # Persist the data\n            instance_id = instance.get(\"instance_id\")\n            instance_data = instance.data_to_store()\n            instance_data_by_id[instance_id] = instance_data\n        set_instances(instance_data_by_id, update=True)\n\n    def create_instance_in_context(self, product_name, data):\n        instance = CreatedInstance(\n            self.product_type, product_name, data, self\n        )\n        self.create_context.creator_adds_instance(instance)\n        return instance\n\n    def create_instance_in_context_from_existing(self, data):\n        instance = CreatedInstance.from_existing(data, self)\n        self.create_context.creator_adds_instance(instance)\n        return instance\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/load/load_texture.html","title":"load_texture","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/load/load_texture.html#client.ayon_substancedesigner.plugins.load.load_texture.SubstanceLoadProjectImage","title":"<code>SubstanceLoadProjectImage</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load Texture for project</p> Source code in <code>client/ayon_substancedesigner/plugins/load/load_texture.py</code> <pre><code>class SubstanceLoadProjectImage(load.LoaderPlugin):\n    \"\"\"Load Texture for project\"\"\"\n\n    product_types = {\"image\", \"textures\"}\n    representations = {\"*\"}\n\n    label = \"Load Texture\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            EnumDef(\n                    \"resource_loading_options\",\n                    label=\"Resource Loading Options\",\n                    items={\n                        1: \"Linked\",\n                        2: \"CopiedAndLinked\",\n                        3: \"BinaryEmbedded\",\n                    },\n                    default=1\n            ),\n        ]\n\n    def load(self, context, name, namespace, options):\n        current_package = get_package_from_current_graph()\n        filepath = self.filepath_from_context(context)\n        resource_embed_method = options.get(\"resource_loading_options\", 1)\n        import_options = {\n            \"resource_loading_options\": resource_embed_method\n        }\n        identifier = self.import_texture(\n            filepath, context, current_package, resource_embed_method)\n        imprint(\n            current_package, name, namespace,\n            context, loader=self, identifier=identifier,\n            options=import_options\n        )\n\n    def update(self, container, context):\n        # As the filepath for SD Resource file is read-only data.\n        # the update function cannot directly set the textures\n        # accordingly to the versions in the existing SD Resource\n        # Therefore, new resource version of the bitmap would be\n        # created when updating\n        current_package = get_package_from_current_graph()\n        filepath = self.filepath_from_context(context)\n        resource_embed_method = int(container[\"resource_loading_options\"])\n        options = {\n            \"resource_loading_options\": resource_embed_method\n        }\n        identifier = self.import_texture(\n            filepath, context, current_package, resource_embed_method)\n        imprint(\n            current_package,\n            container[\"name\"],\n            container.get(\"namespace\", None),\n            context,\n            loader=self,\n            identifier=identifier,\n            options=options\n        )\n\n    def remove(self, container):\n        # TODO: Supports the check across different packages if needed\n        current_package = get_package_from_current_graph()\n        for resource in current_package.getChildrenResources(True):\n            if resource.getClassName() == \"SDResourceBitmap\":\n                if resource.getIdentifier() == container[\"objectName\"]:\n                    resource.delete()\n        remove_container_metadata(container)\n\n    def import_texture(self, filepath, context,\n                       current_package, resource_embed_method):\n        project_name = context[\"project\"][\"name\"]\n        filename = os.path.splitext(os.path.basename(filepath))[0]\n        # identifier would convert \".\" to \"_\", this makes sure\n        # container data taking correct identifier value\n        identifier = filename.replace(\".\", \"_\")\n        if not has_resource_file(current_package):\n            resource_folder = sd.api.sdresourcefolder.SDResourceFolder.sNew(\n                current_package)\n            resource_folder.setIdentifier(f\"{project_name}_resources\")\n        else:\n            resource_folder = get_resource_folder(current_package)\n        bitmap_resource = sd.api.sdresourcebitmap.SDResourceBitmap.sNewFromFile(                # noqa\n            resource_folder, filepath,\n            sd.api.sdresource.EmbedMethod(resource_embed_method)\n        )\n        bitmap_resource.setIdentifier(identifier)\n\n        return identifier\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_current_file.html","title":"collect_current_file","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_current_file.html#client.ayon_substancedesigner.plugins.publish.collect_current_file.CollectCurrentFile","title":"<code>CollectCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Inject the current working file into context</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/collect_current_file.py</code> <pre><code>class CollectCurrentFile(pyblish.api.ContextPlugin):\n    \"\"\"Inject the current working file into context\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Current Workfile\"\n    hosts = [\"substancedesigner\"]\n\n    def process(self, context):\n        host = registered_host()\n        path = host.get_current_workfile()\n        if not path:\n            self.log.error(\"Scene is not saved.\")\n\n        context.data[\"currentFile\"] = path\n        self.log.debug(f\"Current workfile: {path}\")\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_textureset_images.html","title":"collect_textureset_images","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_textureset_images.html#client.ayon_substancedesigner.plugins.publish.collect_textureset_images.CollectTextureSet","title":"<code>CollectTextureSet</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Extract Textures using an output template config</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/collect_textureset_images.py</code> <pre><code>class CollectTextureSet(pyblish.api.InstancePlugin):\n    \"\"\"Extract Textures using an output template config\"\"\"\n\n    label = \"Collect Texture Set images\"\n    hosts = [\"substancedesigner\"]\n    families = [\"textureSet\"]\n    order = pyblish.api.CollectorOrder + 0.01\n\n    def process(self, instance):\n        staging_dir = tempdir.get_temp_dir(\n            instance.context.data[\"projectName\"],\n            use_local_temp=True\n        )\n        creator_attrs = instance.data[\"creator_attributes\"]\n        if creator_attrs.get(\"exportedGraphs\", []):\n            instance.data[\"exportedGraphs\"] = creator_attrs.get(\n                \"exportedGraphs\", [])\n        else:\n            instance.data[\"exportedGraphs\"] = get_sd_graphs_by_package()\n\n        selected_map_identifiers = creator_attrs.get(\n            \"exportedGraphsOutputs\", {})\n        for graph_name in instance.data[\"exportedGraphs\"]:\n            map_identifiers = get_map_identifiers_by_graph(graph_name)\n            if not map_identifiers:\n                continue\n            if selected_map_identifiers:\n                map_identifiers = map_identifiers.intersection(\n                    selected_map_identifiers\n                )\n                if not map_identifiers:\n                    raise KnownPublishError(\n                        f\"Selected output maps {selected_map_identifiers}\"\n                        f\"not found in the graph: {graph_name}\"\n                    )\n\n            instance.data[graph_name] = {\n                \"map_identifiers\": map_identifiers\n            }\n\n            for map_identifier in map_identifiers:\n                self.create_image_instance(\n                    instance, graph_name,\n                    map_identifier, staging_dir\n                )\n\n    def create_image_instance(self, instance, graph_name,\n                              map_identifier, staging_dir):\n        \"\"\"Create a new instance per image.\n\n        The new instances will be of product type `image`.\n\n        \"\"\"\n\n        context = instance.context\n        # Always include the map identifier\n        texture_set_name = f\"{graph_name}_{map_identifier}\"\n\n        # TODO: The product type actually isn't 'texture' currently but\n        #   for now this is only done so the product name starts with\n        #   'texture'\n        image_product_name = f\"{instance.name}_{texture_set_name}\"\n        image_product_group_name = f\"{instance.name}_{graph_name}\"\n        ext = instance.data[\"creator_attributes\"].get(\"exportFileFormat\")\n        # Prepare representation\n        representation = {\n            \"name\": ext.lstrip(\".\"),\n            \"ext\": ext.lstrip(\".\"),\n            \"files\": f\"{image_product_name}.{ext}\",\n        }\n        # Set up the representation for thumbnail generation\n        representation[\"tags\"] = [\"review\"]\n        representation[\"stagingDir\"] = staging_dir\n        # Clone the instance\n        product_type = \"image\"\n        image_instance = context.create_instance(image_product_name)\n        image_instance[:] = instance[:]\n        image_instance.data.update(copy.deepcopy(dict(instance.data)))\n        image_instance.data[\"name\"] = image_product_name\n        image_instance.data[\"label\"] = image_product_name\n        image_instance.data[\"productName\"] = image_product_name\n        image_instance.data[\"productType\"] = product_type\n        image_instance.data[\"family\"] = product_type\n        image_instance.data[\"families\"] = [product_type, \"textures\"]\n        if instance.data[\"creator_attributes\"].get(\"review\"):\n            image_instance.data[\"families\"].append(\"review\")\n\n        image_instance.data[\"representations\"] = [representation]\n\n        # Group the textures together in the loader\n        image_instance.data[\"productGroup\"] = image_product_group_name\n\n        # Store the texture set name and stack name on the instance\n        image_instance.data[\"textureSetName\"] = texture_set_name\n\n        # The current api does not support to get colorspace data\n        # from the output so the colorspace setting is hardcoded for\n        # the colorspace data accordingly to the default output setting\n        if map_identifier in [\"diffuse\", \"basecolor\"]:\n            colorspace = get_colorspace_data()\n        else:\n            colorspace = get_colorspace_data(raw_colorspace=True)\n\n        self.log.debug(f\"{image_product_name} colorspace: {colorspace}\")\n        image_instance.data[\"colorspace\"] = colorspace\n\n        # Store the instance in the original instance as a member\n        instance.append(image_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_textureset_images.html#client.ayon_substancedesigner.plugins.publish.collect_textureset_images.CollectTextureSet.create_image_instance","title":"<code>create_image_instance(instance, graph_name, map_identifier, staging_dir)</code>","text":"<p>Create a new instance per image.</p> <p>The new instances will be of product type <code>image</code>.</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/collect_textureset_images.py</code> <pre><code>def create_image_instance(self, instance, graph_name,\n                          map_identifier, staging_dir):\n    \"\"\"Create a new instance per image.\n\n    The new instances will be of product type `image`.\n\n    \"\"\"\n\n    context = instance.context\n    # Always include the map identifier\n    texture_set_name = f\"{graph_name}_{map_identifier}\"\n\n    # TODO: The product type actually isn't 'texture' currently but\n    #   for now this is only done so the product name starts with\n    #   'texture'\n    image_product_name = f\"{instance.name}_{texture_set_name}\"\n    image_product_group_name = f\"{instance.name}_{graph_name}\"\n    ext = instance.data[\"creator_attributes\"].get(\"exportFileFormat\")\n    # Prepare representation\n    representation = {\n        \"name\": ext.lstrip(\".\"),\n        \"ext\": ext.lstrip(\".\"),\n        \"files\": f\"{image_product_name}.{ext}\",\n    }\n    # Set up the representation for thumbnail generation\n    representation[\"tags\"] = [\"review\"]\n    representation[\"stagingDir\"] = staging_dir\n    # Clone the instance\n    product_type = \"image\"\n    image_instance = context.create_instance(image_product_name)\n    image_instance[:] = instance[:]\n    image_instance.data.update(copy.deepcopy(dict(instance.data)))\n    image_instance.data[\"name\"] = image_product_name\n    image_instance.data[\"label\"] = image_product_name\n    image_instance.data[\"productName\"] = image_product_name\n    image_instance.data[\"productType\"] = product_type\n    image_instance.data[\"family\"] = product_type\n    image_instance.data[\"families\"] = [product_type, \"textures\"]\n    if instance.data[\"creator_attributes\"].get(\"review\"):\n        image_instance.data[\"families\"].append(\"review\")\n\n    image_instance.data[\"representations\"] = [representation]\n\n    # Group the textures together in the loader\n    image_instance.data[\"productGroup\"] = image_product_group_name\n\n    # Store the texture set name and stack name on the instance\n    image_instance.data[\"textureSetName\"] = texture_set_name\n\n    # The current api does not support to get colorspace data\n    # from the output so the colorspace setting is hardcoded for\n    # the colorspace data accordingly to the default output setting\n    if map_identifier in [\"diffuse\", \"basecolor\"]:\n        colorspace = get_colorspace_data()\n    else:\n        colorspace = get_colorspace_data(raw_colorspace=True)\n\n    self.log.debug(f\"{image_product_name} colorspace: {colorspace}\")\n    image_instance.data[\"colorspace\"] = colorspace\n\n    # Store the instance in the original instance as a member\n    instance.append(image_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_textureset_images.html#client.ayon_substancedesigner.plugins.publish.collect_textureset_images.CollectTextureSetStagingDir","title":"<code>CollectTextureSetStagingDir</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Set the staging directory for the <code>textureSet</code> instance taking into account custom staging dirs. Propagate this custom staging dir to the individual texture image instances that are created from the textureSet</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/collect_textureset_images.py</code> <pre><code>class CollectTextureSetStagingDir(pyblish.api.InstancePlugin):\n    \"\"\"Set the staging directory for the `textureSet` instance taking into\n    account custom staging dirs. Propagate this custom staging dir to the\n    individual texture image instances that are created from the textureSet\"\"\"\n\n    label = \"Texture Set Staging Dir\"\n    hosts = [\"substancedesigner\"]\n    families = [\"textureSet\"]\n\n    # Run after CollectManagedStagingDir\n    order = pyblish.api.CollectorOrder + 0.4991\n\n    def process(self, instance):\n\n        staging_dir = instance.data[\"stagingDir\"]\n        # Update image instances and their representations\n        for image_instance in instance:\n\n            # Include the updated config\n            image_instance.data[\"stagingDir\"] = staging_dir\n\n            # Update representation staging dir.\n            for repre in image_instance.data[\"representations\"]:\n                repre[\"stagingDir\"] = staging_dir\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_workfile_representation.html","title":"collect_workfile_representation","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/collect_workfile_representation.html#client.ayon_substancedesigner.plugins.publish.collect_workfile_representation.CollectWorkfileRepresentation","title":"<code>CollectWorkfileRepresentation</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Create a publish representation for the current workfile instance.</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/collect_workfile_representation.py</code> <pre><code>class CollectWorkfileRepresentation(pyblish.api.InstancePlugin):\n    \"\"\"Create a publish representation for the current workfile instance.\"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"Workfile representation\"\n    hosts = [\"substancedesigner\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n\n        context = instance.context\n        current_file = context.data.get(\"currentFile\")\n        if not current_file:\n            self.log.error(\"Current file is not saved. File could not be \"\n                           \"collected as workfile representation.\")\n            return\n\n        folder, file = os.path.split(current_file)\n        filename, ext = os.path.splitext(file)\n\n        instance.data[\"representations\"] = [{\n            \"name\": ext.lstrip(\".\"),\n            \"ext\": ext.lstrip(\".\"),\n            \"files\": file,\n            \"stagingDir\": folder,\n        }]\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/extract_sbsar.html","title":"extract_sbsar","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/extract_sbsar.html#client.ayon_substancedesigner.plugins.publish.extract_sbsar.ExtractSbsar","title":"<code>ExtractSbsar</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract SBSAR</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/extract_sbsar.py</code> <pre><code>class ExtractSbsar(publish.Extractor):\n    \"\"\"Extract SBSAR\n\n    \"\"\"\n\n    label = \"Extract SBSAR\"\n    hosts = [\"substancedesigner\"]\n    families = [\"sbsar\"]\n\n    order = publish.Extractor.order\n\n    def process(self, instance):\n        ctx = sd.getContext()\n        exporterInstance = SDSBSARExporter(ctx, None)\n        exporter = exporterInstance.sNew()\n\n        graph_name = instance.data[\"graph_name\"]\n        sd_graph = get_sd_graph_by_name(graph_name)\n\n        current_file = instance.context.data[\"currentFile\"]\n        filename = os.path.basename(current_file)\n        filename = filename.replace(\"sbs\", \"sbsar\")\n        staging_dir = self.staging_dir(instance)\n        filepath = os.path.normpath(\n            os.path.join(staging_dir, filename))\n        # export the graph with filepath\n        exporter.exportPackageToSBSAR(sd_graph.getPackage(), filepath)\n\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n        representation = {\n            'name': 'sbsar',\n            'ext': 'sbsar',\n            'files': filename,\n            \"stagingDir\": staging_dir,\n        }\n\n        instance.data[\"representations\"].append(representation)\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/extract_textures.html","title":"extract_textures","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/extract_textures.html#client.ayon_substancedesigner.plugins.publish.extract_textures.ExtractTextures","title":"<code>ExtractTextures</code>","text":"<p>               Bases: <code>Extractor</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Extract Textures as Graph Outputs</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/extract_textures.py</code> <pre><code>class ExtractTextures(publish.Extractor,\n                      publish.ColormanagedPyblishPluginMixin):\n    \"\"\"Extract Textures as Graph Outputs\n\n    \"\"\"\n\n    label = \"Extract Textures as Graph Outputs\"\n    hosts = [\"substancedesigner\"]\n    families = [\"textureSet\"]\n\n    # Run before thumbnail extractors\n    order = publish.Extractor.order - 0.1\n\n    def process(self, instance):\n        staging_dir = self.staging_dir(instance)\n        extension = instance.data[\"creator_attributes\"].get(\"exportFileFormat\")\n\n        for graph_name in instance.data[\"exportedGraphs\"]:\n            selected_map_identifiers = instance.data[graph_name].get(\n                \"map_identifiers\", {})\n            target_sd_graph = get_sd_graph_by_name(graph_name)\n            result = export_outputs_by_sd_graph(\n                instance.name, target_sd_graph,\n                staging_dir, extension,\n                selected_map_identifiers\n            )\n            if not result:\n                raise KnownPublishError(\n                    \"Failed to export texture output in graph: {}\".format(\n                        graph_name)\n                )\n\n            self.log.debug(f\"Extracting to {staging_dir}\")\n        # We'll insert the color space data for each image instance that we\n        # added into this texture set. The collector couldn't do so because\n        # some anatomy and other instance data needs to be collected prior\n        context = instance.context\n        for image_instance in instance:\n            representation = next(iter(image_instance.data[\"representations\"]))\n\n            colorspace = image_instance.data.get(\"colorspace\")\n            if not colorspace:\n                self.log.debug(\"No color space data present for instance: \"\n                               f\"{image_instance}\")\n                continue\n\n            self.set_representation_colorspace(representation,\n                                               context=context,\n                                               colorspace=colorspace)\n        # The TextureSet instance should not be integrated. It generates no\n        # output data. Instead the separated texture instances are generated\n        # from it which themselves integrate into the database.\n        instance.data[\"integrate\"] = False\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/increment_workfile.html","title":"increment_workfile","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/increment_workfile.html#client.ayon_substancedesigner.plugins.publish.increment_workfile.IncrementWorkfileVersion","title":"<code>IncrementWorkfileVersion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Increment current workfile version.</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/increment_workfile.py</code> <pre><code>class IncrementWorkfileVersion(pyblish.api.ContextPlugin):\n    \"\"\"Increment current workfile version.\"\"\"\n\n    order = pyblish.api.IntegratorOrder + 1\n    label = \"Increment Workfile Version\"\n    optional = True\n    hosts = [\"substancedesigner\"]\n\n    def process(self, context):\n\n        assert all(result[\"success\"] for result in context.data[\"results\"]), (\n            \"Publishing not successful so version is not increased.\")\n\n        host = registered_host()\n        path = context.data[\"currentFile\"]\n        self.log.info(f\"Incrementing current workfile to: {path}\")\n        host.save_workfile(version_up(path))\n</code></pre>"},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/save_workfile.html","title":"save_workfile","text":""},{"location":"autoapi/client/ayon_substancedesigner/plugins/publish/save_workfile.html#client.ayon_substancedesigner.plugins.publish.save_workfile.SaveCurrentWorkfile","title":"<code>SaveCurrentWorkfile</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save current workfile</p> Source code in <code>client/ayon_substancedesigner/plugins/publish/save_workfile.py</code> <pre><code>class SaveCurrentWorkfile(pyblish.api.ContextPlugin):\n    \"\"\"Save current workfile\"\"\"\n\n    label = \"Save current workfile\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"substancedesigner\"]\n\n    def process(self, context):\n\n        host = registered_host()\n        current = host.get_current_workfile()\n        if context.data[\"currentFile\"] != current:\n            raise KnownPublishError(\"Workfile has changed during publishing!\")\n\n        if host.workfile_has_unsaved_changes():\n            self.log.info(\"Saving current file: {}\".format(current))\n            host.save_workfile(current)\n        else:\n            self.log.debug(\"Skipping workfile save because there are no \"\n                           \"unsaved changes.\")\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/main.html#server.settings.main.image_format_enum","title":"<code>image_format_enum()</code>","text":"<p>Return enumerator for image output formats.</p> Source code in <code>server/settings/main.py</code> <pre><code>def image_format_enum():\n    \"\"\"Return enumerator for image output formats.\"\"\"\n    return [\n        {\"label\": \"bmp\", \"value\": \"bmp\"},\n        {\"label\": \"dds\", \"value\": \"dds\"},\n        {\"label\": \"jpeg\", \"value\": \"jpeg\"},\n        {\"label\": \"png\", \"value\": \"png\"},\n        {\"label\": \"tga\", \"value\": \"tga\"},\n        {\"label\": \"tif\", \"value\": \"tif\"},\n        {\"label\": \"surface\", \"value\": \"surface\"},\n        {\"label\": \"hdr\", \"value\": \"hdr\"},\n        {\"label\": \"exr\", \"value\": \"exr\"},\n        {\"label\": \"jif\", \"value\": \"jif\"},\n        {\"label\": \"jpe\", \"value\": \"jpe\"},\n        {\"label\": \"webp\", \"value\": \"webp\"},\n    ]\n</code></pre>"}]}